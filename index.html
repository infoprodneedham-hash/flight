<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>F-18 Desert Storm: Desktop & Mobile</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Consolas', monospace; touch-action: none; user-select: none; -webkit-user-select: none; }
        #game-container { position: relative; width: 100vw; height: 100vh; }
        
        /* --- HUD --- */
        #hud-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; overflow: hidden; }
        .hud-text { color: #0f0; text-shadow: 1px 1px 0 #000; font-weight: bold; position: absolute; font-size: 14px; }
        #info-left { top: 20px; left: 20px; text-align: left; }
        #info-right { top: 20px; right: 20px; text-align: right; }
        #msg-center { top: 20%; width: 100%; text-align: center; color: #fff; font-size: 20px; text-shadow: 0 0 5px red; display: none; }

        /* Crosshair */
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            transform: translate(-50%, -50%);
            border: 2px solid rgba(0, 255, 0, 0.4); border-radius: 50%;
        }
        #crosshair::after {
            content: ''; position: absolute; top: 50%; left: 50%; width: 2px; height: 2px; background: #0f0; transform: translate(-50%, -50%);
        }

        /* Artificial Horizon */
        #horizon-container { position: absolute; top: 50%; left: 50%; width: 0; height: 0; overflow: visible; }
        #pitch-ladder {
            position: absolute; width: 200px; height: 600px; left: -100px; top: -300px;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }
        .pitch-line {
            width: 100%; height: 1px; background: rgba(0, 255, 0, 0.3); position: absolute; display: flex; justify-content: space-between;
        }
        .pitch-line::before, .pitch-line::after { content: ''; width: 10px; height: 4px; border-top: 1px solid #0f0; display: block; }
        .zero-line { background: rgba(0, 255, 0, 0.6); width: 140px; left: 30px; } 

        /* Target Box */
        #target-box {
            position: absolute; width: 40px; height: 40px; border: 2px solid #0f0; box-sizing: border-box; transform: translate(-50%, -50%); display: none; transition: border-color 0.1s;
        }
        #target-label { position: absolute; bottom: -15px; width: 100%; text-align: center; font-size: 10px; color: #0f0; }

        /* --- CONTROLS --- */
        /* Visible only on Touch devices usually, but kept here for hybrid support */
        .control-layer { position: absolute; bottom: 20px; width: 100%; height: 140px; pointer-events: auto; display: flex; justify-content: space-between; padding: 0 30px; box-sizing: border-box; }
        
        #joystick-area { width: 120px; height: 120px; background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.2); border-radius: 50%; position: relative; }
        #stick { width: 50px; height: 50px; background: rgba(0, 255, 0, 0.3); border-radius: 50%; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); box-shadow: 0 0 10px #0f0; }

        #buttons-area { display: flex; gap: 15px; align-items: flex-end; }
        .btn { width: 60px; height: 60px; border-radius: 50%; border: 2px solid #fff; color: white; font-weight: bold; display: flex; align-items: center; justify-content: center; font-size: 12px; background: rgba(0,0,0,0.5); cursor: pointer; }
        .btn:active { background: #fff; color: #000; }
        #btn-fire { border-color: #ff4444; color: #ff4444; }
        #throttle-slider { width: 40px; height: 120px; background: rgba(0,0,0,0.5); border: 1px solid #fff; position: relative; border-radius: 4px; margin-right: 10px; }
        #throttle-bar { position: absolute; bottom: 0; left: 0; width: 100%; background: #0088ff; height: 0%; transition: height 0.1s; }
        #throttle-knob { position: absolute; bottom: 0; left: -5px; width: 50px; height: 20px; background: #fff; transform: translateY(50%); border-radius: 2px; text-align: center; color: black; font-size: 10px; line-height: 20px; pointer-events: none;}

        /* Controls Hint */
        #pc-controls-hint {
            position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.5); font-size: 12px; text-align: center; width: 100%; pointer-events: none;
        }

        /* --- MENUS --- */
        #overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: flex; flex-direction: column; justify-content: center; align-items: center; color: white; z-index: 100; pointer-events: auto; }
        h1 { margin: 0 0 10px 0; color: #00ccff; text-shadow: 0 0 10px #00ccff; font-style: italic; }
        p { color: #aaa; margin-bottom: 20px; text-align: center; max-width: 400px; font-size: 14px; line-height: 1.5; }
        button.start { background: #00ccff; border: none; padding: 10px 40px; font-size: 18px; font-weight: bold; cursor: pointer; border-radius: 5px; color: #000; }
        .key { border: 1px solid #aaa; padding: 2px 5px; border-radius: 3px; font-size: 12px; color: #fff; display: inline-block; margin: 0 2px;}
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="game-container">
        <div id="hud-layer">
            <div id="horizon-container"><div id="pitch-ladder"></div></div>
            <div id="target-box"><div id="target-label">LOCK</div></div>
            <div id="crosshair"></div>
            <div id="info-left">
                SPD: <span id="hud-spd">0</span><br>
                ALT: <span id="hud-alt">0</span><br>
                THR: <span id="hud-thr">0</span>%<br>
                FLP: <span id="hud-flaps">OFF</span>
            </div>
            <div id="info-right">
                TGT: <span id="hud-tgt">NONE</span><br>
                DIST: <span id="hud-dist">---</span>
            </div>
            <div id="msg-center"></div>
            <div id="pc-controls-hint">Desktop: Arrow Keys, Space (Thrust), Ctrl (Slow), Shift (Flaps), N (Gun), M (Missile)</div>
        </div>

        <div class="control-layer">
            <div id="joystick-area"><div id="stick"></div></div>
            <div id="buttons-area">
                <div id="throttle-slider"><div id="throttle-bar"></div><div id="throttle-knob">THR</div></div>
                <div style="display:flex; flex-direction: column; gap:10px;">
                     <div class="btn" id="btn-flaps" style="border-color: yellow; color: yellow;">FLAPS</div>
                     <div class="btn" id="btn-missile">MSL</div>
                </div>
                <div class="btn" id="btn-fire">GUN</div>
            </div>
        </div>

        <div id="overlay">
            <h1>SKY STRIKER V3</h1>
            <p>
                <b>MOBILE:</b> Left Stick to fly, Slider for speed.<br>
                <b>DESKTOP:</b> <span class="key">Arrows</span> Pitch/Roll | <span class="key">Space</span> Thrust | <span class="key">L-Ctrl</span> Brake | <span class="key">Shift</span> Flaps | <span class="key">N</span> Gun | <span class="key">M</span> Missile
            </p>
            <button class="start" id="start-btn">TAKEOFF</button>
        </div>
    </div>

    <script>
        const CONFIG = {
            turnSpeed: 1.2,
            maxSpeed: 3.5,
            stallSpeed: 0.8,
            mapScale: 5000,
            camLag: 0.1
        };

        const state = {
            flying: false,
            speed: 0,
            throttle: 0,
            inputs: { x: 0, y: 0 },
            keys: { up: false, down: false, left: false, right: false, space: false, ctrl: false, n: false },
            flaps: false,
            playerObj: null,
            enemies: [],
            bullets: [],
            missiles: [],
            particles: [],
            lockedTarget: null
        };

        // --- THREE JS SETUP ---
        const container = document.getElementById('game-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0xdcb286, 500, 2500); 
        scene.background = new THREE.Color(0x87CEEB);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 5000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        container.insertBefore(renderer.domElement, document.getElementById('hud-layer'));

        const hemiLight = new THREE.HemisphereLight(0xffffff, 0xdcb286, 0.8);
        scene.add(hemiLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(100, 500, 200);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // --- ASSETS ---
        // Terrain
        const groundGeo = new THREE.PlaneGeometry(CONFIG.mapScale, CONFIG.mapScale, 64, 64);
        const pos = groundGeo.attributes.position;
        for(let i=0; i<pos.count; i++){
            const x = pos.getX(i); const y = pos.getY(i);
            const z = (Math.sin(x/200) * Math.cos(y/200) * 20) + (Math.random()*2);
            pos.setZ(i, z);
        }
        groundGeo.computeVertexNormals();
        
        const canvas = document.createElement('canvas'); canvas.width = 512; canvas.height = 512;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#dcb286'; ctx.fillRect(0,0,512,512);
        ctx.strokeStyle = '#cda175'; ctx.lineWidth = 2; ctx.strokeRect(0,0,512,512);
        ctx.beginPath();
        for(let i=0; i<=512; i+=64) { ctx.moveTo(i,0); ctx.lineTo(i,512); ctx.moveTo(0,i); ctx.lineTo(512,i); }
        ctx.stroke();
        const tex = new THREE.CanvasTexture(canvas);
        tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping; tex.repeat.set(40, 40);
        
        const ground = new THREE.Mesh(groundGeo, new THREE.MeshLambertMaterial({ map: tex }));
        ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);

        const runway = new THREE.Mesh(new THREE.PlaneGeometry(80, 1000), new THREE.MeshLambertMaterial({ color: 0x333333 }));
        runway.rotation.x = -Math.PI/2; runway.position.set(0, 0.5, 0); runway.receiveShadow = true; scene.add(runway);

        // Player
        function createF18() {
            const group = new THREE.Group();
            const grey = new THREE.MeshPhongMaterial({color: 0x777777, shininess: 50});
            const glass = new THREE.MeshPhongMaterial({color: 0x00aaff, shininess: 100, opacity: 0.6, transparent: true});
            const body = new THREE.Mesh(new THREE.ConeGeometry(1.2, 10, 8), grey); body.rotation.x = Math.PI/2; group.add(body);
            const canopy = new THREE.Mesh(new THREE.ConeGeometry(0.7, 3, 8), glass); canopy.rotation.x = Math.PI/2; canopy.position.set(0, 1, -1); group.add(canopy);
            const wings = new THREE.Mesh(new THREE.BoxGeometry(10, 0.2, 4), grey); wings.position.set(0, 0, 1); group.add(wings);
            const tailL = new THREE.Mesh(new THREE.BoxGeometry(0.2, 2.5, 2), grey); tailL.position.set(1.5, 1, 3.5); tailL.rotation.z = Math.PI/8; group.add(tailL);
            const tailR = tailL.clone(); tailR.position.set(-1.5, 1, 3.5); tailR.rotation.z = -Math.PI/8; group.add(tailR);
            const exL = new THREE.Object3D(); exL.position.set(0.8, 0, 5); group.add(exL);
            const exR = new THREE.Object3D(); exR.position.set(-0.8, 0, 5); group.add(exR);
            group.castShadow = true; group.userData = { exhausts: [exL, exR] };
            return group;
        }
        state.playerObj = createF18(); state.playerObj.position.set(0, 2, 400); scene.add(state.playerObj);
        const camTarget = new THREE.Object3D(); scene.add(camTarget);

        // Enemies
        function createTarget(type, x, z) {
            const obj = new THREE.Group();
            if (type === 'tower') {
                const base = new THREE.Mesh(new THREE.BoxGeometry(15, 60, 15), new THREE.MeshPhongMaterial({color: 0x555555})); base.position.y = 30;
                const dish = new THREE.Mesh(new THREE.CylinderGeometry(1, 8, 5, 8), new THREE.MeshPhongMaterial({color: 0xaa0000})); dish.rotation.x = Math.PI/2; dish.position.y = 60;
                obj.add(base, dish); obj.userData = { hp: 500, type: 'tower', name: 'COMMS TOWER' };
            } else {
                const jet = createF18(); jet.children.forEach(c => { if(c.material) c.material = new THREE.MeshPhongMaterial({color: 0x882222}); });
                obj.add(jet); obj.userData = { hp: 50, type: 'bogie', speed: 1.5, name: 'BOGIE' }; obj.position.y = 200;
            }
            obj.position.x = x; obj.position.z = z; scene.add(obj); state.enemies.push(obj);
        }
        createTarget('tower', 0, -1500); createTarget('bogie', -500, -800); createTarget('bogie', 500, -1200); createTarget('bogie', -800, -2000);

        // --- INPUT HANDLING (KEYBOARD & TOUCH) ---
        
        // 1. Keyboard Listeners
        window.addEventListener('keydown', (e) => {
            if(e.repeat) return;
            switch(e.key) {
                case 'ArrowUp': state.keys.up = true; break;
                case 'ArrowDown': state.keys.down = true; break;
                case 'ArrowLeft': state.keys.left = true; break;
                case 'ArrowRight': state.keys.right = true; break;
                case ' ': state.keys.space = true; break; // Throttle Up
                case 'Control': state.keys.ctrl = true; break; // Throttle Down
                case 'n': case 'N': state.keys.n = true; break; // Gun hold
                case 'm': case 'M': fireMissile(); break; // Missile trigger
                case 'Shift': toggleFlaps(); break;
            }
        });

        window.addEventListener('keyup', (e) => {
            switch(e.key) {
                case 'ArrowUp': state.keys.up = false; break;
                case 'ArrowDown': state.keys.down = false; break;
                case 'ArrowLeft': state.keys.left = false; break;
                case 'ArrowRight': state.keys.right = false; break;
                case ' ': state.keys.space = false; break;
                case 'Control': state.keys.ctrl = false; break;
                case 'n': case 'N': state.keys.n = false; break;
            }
        });

        // 2. Touch Logic
        const stick = document.getElementById('stick');
        const stickArea = document.getElementById('joystick-area');
        let joyTouchId = null;

        stickArea.addEventListener('touchstart', e => { e.preventDefault(); joyTouchId = e.changedTouches[0].identifier; handleJoy(e.changedTouches[0].clientX, e.changedTouches[0].clientY); }, {passive:false});
        stickArea.addEventListener('touchmove', e => { e.preventDefault(); for(let t of e.changedTouches) if(t.identifier===joyTouchId) handleJoy(t.clientX, t.clientY); }, {passive:false});
        stickArea.addEventListener('touchend', e => { for(let t of e.changedTouches) if(t.identifier===joyTouchId) { joyTouchId=null; state.inputs.x=0; state.inputs.y=0; stick.style.transform=`translate(-50%,-50%)`; } });

        function handleJoy(cx, cy) {
            const rect = stickArea.getBoundingClientRect();
            let dx = cx - (rect.left + rect.width/2);
            let dy = cy - (rect.top + rect.height/2);
            const dist = Math.sqrt(dx*dx+dy*dy);
            const maxR = 40;
            if (dist > maxR) { dx = (dx/dist)*maxR; dy = (dy/dist)*maxR; }
            stick.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
            state.inputs.x = dx / maxR; state.inputs.y = dy / maxR;
        }

        const throttleEl = document.getElementById('throttle-slider');
        throttleEl.addEventListener('touchmove', e => {
            e.preventDefault();
            const rect = throttleEl.getBoundingClientRect();
            let val = 1.0 - ((e.touches[0].clientY - rect.top) / rect.height);
            setThrottle(Math.max(0, Math.min(1, val)));
        }, {passive:false});

        function setThrottle(val) {
            state.throttle = val;
            document.getElementById('throttle-bar').style.height = (val*100)+'%';
            document.getElementById('throttle-knob').style.bottom = (val*100)+'%';
            document.getElementById('hud-thr').innerText = Math.floor(val*100);
        }

        // Buttons
        function toggleFlaps() {
            state.flaps = !state.flaps;
            document.getElementById('hud-flaps').innerText = state.flaps ? "ON" : "OFF";
            document.getElementById('btn-flaps').style.background = state.flaps ? '#00aa00' : '';
        }
        document.getElementById('btn-flaps').addEventListener('click', toggleFlaps);
        document.getElementById('btn-fire').addEventListener('touchstart', (e)=>{ e.preventDefault(); state.keys.n = true; });
        document.getElementById('btn-fire').addEventListener('touchend', (e)=>{ e.preventDefault(); state.keys.n = false; });
        document.getElementById('btn-missile').addEventListener('click', fireMissile);
        document.getElementById('start-btn').addEventListener('click', () => { document.getElementById('overlay').style.display = 'none'; state.flying = true; });

        // --- GAME LOGIC ---

        function fireGun() {
            if(!state.flying) return;
            const b = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 5), new THREE.MeshBasicMaterial({color: 0xffff00}));
            const offset = new THREE.Vector3(0, 0, -2).applyMatrix4(state.playerObj.matrixWorld);
            b.position.copy(offset); b.quaternion.copy(state.playerObj.quaternion);
            scene.add(b); state.bullets.push({mesh: b, life: 60});
        }

        function fireMissile() {
            if(!state.flying || !state.lockedTarget) return;
            const m = new THREE.Mesh(new THREE.ConeGeometry(0.3, 2, 8), new THREE.MeshBasicMaterial({color: 0xffffff}));
            m.geometry.rotateX(-Math.PI/2);
            m.position.copy(state.playerObj.position); m.quaternion.copy(state.playerObj.quaternion); m.translateY(-1);
            scene.add(m);
            state.missiles.push({ mesh: m, target: state.lockedTarget, speed: state.speed + 0.5, turnRate: 0.1, life: 300 });
        }

        function createParticle(pos, type) {
            const geo = new THREE.PlaneGeometry(type==='fire'?4:1, type==='fire'?4:1);
            const mat = new THREE.MeshBasicMaterial({ color: type==='fire'?0xffaa00:0xaaaaaa, transparent: true, opacity: 0.8, side: THREE.DoubleSide });
            const mesh = new THREE.Mesh(geo, mat); mesh.position.copy(pos); mesh.lookAt(camera.position); scene.add(mesh);
            state.particles.push({ mesh: mesh, life: type==='fire'?20:40, maxLife: type==='fire'?20:40, scaleDelta: type==='fire'?0.5:0.1 });
        }

        function updatePhysics() {
            const jet = state.playerObj;

            // 1. INPUT MERGING (Keyboard overrides if active)
            let rollInput = state.inputs.x;
            let pitchInput = state.inputs.y;

            // Simple keyboard ramp for smoothness
            if (state.keys.left) rollInput = -1; 
            else if (state.keys.right) rollInput = 1;
            
            if (state.keys.up) pitchInput = 1; // Pulling back on stick
            else if (state.keys.down) pitchInput = -1;

            // Keyboard Throttle
            if(state.keys.space && state.throttle < 1.0) setThrottle(state.throttle + 0.01);
            if(state.keys.ctrl && state.throttle > 0.0) setThrottle(state.throttle - 0.01);

            // Gun Hold
            if(state.keys.n && Math.random() > 0.5) fireGun(); // Simple rate limiter

            // 2. PHYSICS
            const targetSpd = state.throttle * CONFIG.maxSpeed;
            if (state.speed < targetSpd) state.speed += 0.02; else state.speed -= 0.01;
            if(state.flaps) state.speed *= 0.99;

            jet.rotateZ(-rollInput * 0.04);
            jet.rotateX(-pitchInput * 0.03);
            jet.translateZ(-state.speed);

            const lift = (state.speed * state.speed) * (state.flaps ? 0.3 : 0.15);
            jet.position.y -= (0.4 - lift); // Gravity

            if (jet.position.y < 2) {
                jet.position.y = 2; jet.rotation.x *= 0.9; jet.rotation.z *= 0.9;
                if(state.speed > 1) createParticle(jet.position, 'dust');
            }
        }

        function updateCombat() {
            // Locking
            const jet = state.playerObj;
            let best=null, minA=0.4;
            const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(jet.quaternion);
            state.enemies.forEach(t => {
                if(t.userData.hp <= 0) return;
                const dir = new THREE.Vector3().subVectors(t.position, jet.position).normalize();
                const a = fwd.angleTo(dir);
                if(a < minA) { minA=a; best=t; }
            });
            state.lockedTarget = best;
            
            // UI Box
            const box = document.getElementById('target-box');
            if(best) {
                const p = best.position.clone().project(camera);
                if(p.z < 1) {
                    box.style.display = 'block';
                    box.style.left = ((p.x*0.5+0.5)*container.clientWidth)+'px';
                    box.style.top = (-(p.y*0.5-0.5)*container.clientHeight)+'px';
                    box.style.borderColor = (minA<0.1)?'red':'lime';
                    document.getElementById('hud-tgt').innerText = best.userData.name;
                    document.getElementById('hud-dist').innerText = Math.floor(jet.position.distanceTo(best.position));
                } else box.style.display = 'none';
            } else { box.style.display = 'none'; document.getElementById('hud-tgt').innerText="NONE"; }

            // Update Projectiles
            [state.bullets, state.missiles].forEach(arr => {
                for(let i=arr.length-1; i>=0; i--) {
                    const p = arr[i];
                    if(p.turnRate) { // Missile logic
                        p.mesh.translateY(p.speed);
                        if(p.target && p.target.parent) {
                            const tPos = p.target.position.clone();
                            const mtx = new THREE.Matrix4().lookAt(p.mesh.position, tPos, new THREE.Vector3(0,1,0));
                            const tQ = new THREE.Quaternion().setFromRotationMatrix(mtx).multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0), Math.PI/2));
                            p.mesh.quaternion.slerp(tQ, p.turnRate);
                        }
                    } else { // Bullet logic
                        p.mesh.translateZ(-10);
                    }
                    
                    p.life--;
                    let hit = false;
                    state.enemies.forEach(e => {
                        if(!hit && e.userData.hp > 0 && e.position.distanceTo(p.mesh.position) < (p.turnRate?20:15)) {
                            createParticle(e.position, 'fire');
                            e.userData.hp -= (p.turnRate?100:10);
                            if(e.userData.hp<=0) {
                                for(let k=0; k<10; k++) createParticle(e.position, 'fire');
                                scene.remove(e);
                                document.getElementById('msg-center').style.display='block';
                                document.getElementById('msg-center').innerText="DESTROYED: "+e.userData.name;
                                setTimeout(()=>document.getElementById('msg-center').style.display='none', 2000);
                            }
                            hit=true;
                        }
                    });
                    if(p.life<=0 || hit) { scene.remove(p.mesh); arr.splice(i,1); }
                }
            });
        }

        // --- LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            if(state.flying) {
                updatePhysics();
                
                // Camera
                const rel = new THREE.Vector3(0, 8, 25).applyMatrix4(state.playerObj.matrixWorld);
                camera.position.lerp(rel, CONFIG.camLag);
                camTarget.position.lerp(new THREE.Vector3(0,0,-50).applyMatrix4(state.playerObj.matrixWorld), CONFIG.camLag);
                camera.lookAt(camTarget.position);

                updateCombat();
                
                // Visuals
                if(state.speed>0.5) state.playerObj.userData.exhausts.forEach(ex => { const p=new THREE.Vector3(); ex.getWorldPosition(p); createParticle(p.addScalar((Math.random()-0.5)), 'smoke'); });
                state.particles.forEach((p,i) => {
                    p.life--; p.mesh.scale.setScalar(1+((p.maxLife-p.life)*p.scaleDelta)); p.mesh.material.opacity=p.life/p.maxLife;
                    if(p.life<=0){ scene.remove(p.mesh); state.particles.splice(i,1); }
                });

                // HUD
                const euler = new THREE.Euler().setFromQuaternion(state.playerObj.quaternion);
                document.getElementById('horizon-container').style.transform = `translate(-50%,-50%) rotate(${euler.z * (180/Math.PI)}deg)`;
                document.getElementById('pitch-ladder').style.transform = `translateY(${euler.x * (180/Math.PI) * 8}px)`;
                document.getElementById('hud-spd').innerText = Math.floor(state.speed*200);
                document.getElementById('hud-alt').innerText = Math.floor(state.playerObj.position.y*10);

                // AI Move
                state.enemies.forEach(e => { if(e.userData.type==='bogie') { e.translateZ(1.0); if(e.position.length()>3000) e.lookAt(0,200,0); } });
            }
            renderer.render(scene, camera);
        }

        // Ladder Gen
        for(let d=90; d>=-90; d-=10) {
            const l = document.createElement('div'); l.className = d===0?'pitch-line zero-line':'pitch-line';
            l.style.top = (300-(d*8))+'px'; if(d!==0) l.innerHTML=`<span style="position:absolute;left:-25px;color:#0f0;font-size:10px">${d}</span><span style="position:absolute;right:-25px;color:#0f0;font-size:10px">${d}</span>`;
            document.getElementById('pitch-ladder').appendChild(l);
        }

        window.addEventListener('resize', () => { camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
        animate();
    </script>
</body>
</html>
